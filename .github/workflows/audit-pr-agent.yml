name: Audit PR Agent

on:
  pull_request_target:
    types: [labeled, reopened, synchronize, ready_for_review]
  workflow_dispatch:

permissions:
  actions: read
  contents: read
  issues: write
  pull-requests: read

jobs:
  pr-agent:
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      issues: write
      pull-requests: read
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Ensure audit agent labels exist
        uses: actions/github-script@v7
        with:
          script: |
            const labels = [
              { name: 'audit:agent', color: '6f42c1', description: 'Opt-in Copilot agent pass for PRs.' },
              { name: 'audit:ux', color: '0E8A16', description: 'UX audit finding.' },
              { name: 'audit:ia', color: '1D76DB', description: 'Information architecture audit finding.' },
              { name: 'audit:seo', color: '0E8A16', description: 'SEO quality finding.' },
              { name: 'audit:correctness', color: 'B60205', description: 'Correctness or runtime quality finding.' },
              { name: 'ai:ready', color: '0366D6', description: 'Ready for AI agent execution.' },
              { name: 'ai:in-progress', color: 'FBCA04', description: 'AI agent is processing.' },
            ];
            const { owner, repo } = context.repo;
            for (const label of labels) {
              try {
                await github.rest.issues.createLabel({ owner, repo, ...label });
              } catch (error) {
                if (error.status !== 422) throw error;
              }
            }

      - name: Resolve PR context and guard conditions
        id: guard
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            let pr = null;

            if (context.eventName === 'workflow_dispatch') {
              const openPulls = await github.paginate(github.rest.pulls.list, {
                owner,
                repo,
                state: 'open',
                base: 'main',
                per_page: 100,
              });
              if (openPulls.length === 1) {
                pr = openPulls[0];
                core.notice(`workflow_dispatch auto-selected PR #${pr.number}.`);
              } else if (openPulls.length === 0) {
                core.setFailed(
                  'No open PR targeting main was found for workflow_dispatch auto-detect. ' +
                  'Open a PR first and rerun this workflow.'
                );
                return;
              } else {
                const candidates = openPulls
                  .slice(0, 15)
                  .map((candidate) => `#${candidate.number} (${candidate.head?.ref || 'unknown'} -> ${candidate.base?.ref || 'main'})`)
                  .join(', ');
                core.setFailed(
                  'Multiple open PRs target main; cannot auto-select safely. ' +
                  `Candidates: ${candidates}. ` +
                  'Close or merge non-target PRs, then rerun this workflow.'
                );
                return;
              }
            } else {
              pr = context.payload.pull_request;
            }

            if (!pr) {
              core.setFailed('Unable to resolve pull request context.');
              return;
            }

            const hasAgentLabel = (pr.labels || []).some((label) => label.name === 'audit:agent');
            const prHeadSha = pr.head?.sha || '';
            core.setOutput('pr_number', String(pr.number));
            core.setOutput('pr_url', pr.html_url);
            core.setOutput('is_fork', pr.head?.repo?.fork ? 'true' : 'false');
            core.setOutput('has_agent_label', hasAgentLabel ? 'true' : 'false');
            core.setOutput('pr_head_sha', prHeadSha);
            const shouldRun = context.eventName === 'workflow_dispatch' || hasAgentLabel;
            core.setOutput('should_run', shouldRun ? 'true' : 'false');
            core.setOutput('resolution_mode', context.eventName === 'workflow_dispatch' ? 'manual' : 'pull_request_target');

            let evidenceRunUrl = '';
            try {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id: 'audit-pr-evidence.yml',
                event: 'pull_request',
                status: 'completed',
                per_page: 50,
              });
              const matching = runs.data.workflow_runs.find((run) => {
                if (run.conclusion !== 'success') return false;
                if (run.head_sha !== prHeadSha) return false;
                return (run.pull_requests || []).some((linked) => linked.number === pr.number);
              });
              evidenceRunUrl = matching?.html_url || '';
              if (evidenceRunUrl) {
                core.notice(`Selected evidence run for PR #${pr.number}: ${evidenceRunUrl}`);
              } else {
                core.notice(`No successful Audit PR Evidence workflow run found for PR #${pr.number} at current head SHA ${prHeadSha}. Maintainers should rerun Audit PR Evidence.`);
              }
            } catch (error) {
              core.notice(`Unable to resolve PR evidence run URL: ${error.message}`);
            }
            core.setOutput('evidence_run_url', evidenceRunUrl);

            if (context.eventName !== 'workflow_dispatch' && !hasAgentLabel) {
              core.notice('Skipping agent flow: PR does not have audit:agent label.');
            }

      - name: Stop when audit:agent label is not present
        if: steps.guard.outputs.should_run != 'true'
        run: |
          echo "audit:agent label not present; skipping."
          exit 0

      - name: Build PR agent issue body
        if: steps.guard.outputs.should_run == 'true'
        run: |
          python3 - <<'PY'
          from pathlib import Path
          prompt = Path("scripts/audit/render_report_prompt.md").read_text(encoding="utf-8").strip()
          pr_number = "${{ steps.guard.outputs.pr_number }}"
          pr_url = "${{ steps.guard.outputs.pr_url }}"
          evidence_url = "${{ steps.guard.outputs.evidence_run_url }}"
          is_fork = "${{ steps.guard.outputs.is_fork }}" == "true"

          note = ""
          if is_fork:
              note = (
                  "Fork PR detected. Automatic Copilot assignment is skipped for safety.\n"
                  "Maintainer can manually run this workflow from a trusted context and assign @copilot."
              )

          focus = [
              "- Identify correctness risks, broken flows, console errors, and UI/UX regressions in the PR scope.",
              "- Cite evidence artifact paths and source paths for every finding.",
              "- Keep the top issues tight and implementation-ready.",
          ]

          body = [
              f"# PR Audit Agent Request for PR #{pr_number}",
              "",
              f"- PR: {pr_url}",
              "- Scope trigger: `audit:agent`",
              f"- Latest PR evidence run: {evidence_url or 'not found (run `Audit PR Evidence` manually)'}",
              "",
              note,
              "",
              "## Evidence",
              "",
              "Use the latest successful `Audit PR Evidence` workflow run for this PR.",
              "",
              "## Focus",
          ]

          body.extend(focus)
          body.extend(
              [
                  "",
                  "## Required output contract",
                  "",
                  "```md",
                  prompt,
                  "```",
              ]
          )

          Path("pr-agent-body.md").write_text(
              "\n".join([line for line in body if line is not None]).strip() + "\n",
              encoding="utf-8",
          )
          PY

      - name: Create or update PR audit agent issue
        if: steps.guard.outputs.should_run == 'true'
        id: issue
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const prNumber = Number('${{ steps.guard.outputs.pr_number }}');
            const body = fs.readFileSync('pr-agent-body.md', 'utf8');
            const title = `PR Audit Agent - PR #${prNumber}`;
            const baselineLabels = ['audit:agent', 'audit:ux', 'audit:ia', 'audit:correctness'];
            const readyLabel = 'ai:ready';
            const inProgressLabel = 'ai:in-progress';

            const mergeLabels = (existing, { targetAiState }) => {
              const current = (existing || []).map((label) =>
                typeof label === 'string' ? label : label.name,
              );
              const preserved = current.filter((label) => label !== readyLabel && label !== inProgressLabel);
              return Array.from(new Set([...preserved, ...baselineLabels, targetAiState]));
            };

            const openIssues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: 'open',
              per_page: 100,
            });
            const existing = openIssues.find((issue) => !issue.pull_request && issue.title === title);
            if (existing) {
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: existing.number,
                body,
                labels: mergeLabels(existing.labels, { targetAiState: readyLabel }),
              });
              core.setOutput('issue_number', String(existing.number));
              return;
            }

            const created = await github.rest.issues.create({
              owner,
              repo,
              title,
              body,
              labels: mergeLabels([], { targetAiState: readyLabel }),
            });
            core.setOutput('issue_number', String(created.data.number));

      - name: Assign to Copilot when safe
        if: steps.guard.outputs.should_run == 'true' && steps.guard.outputs.is_fork != 'true'
        uses: actions/github-script@v7
        env:
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
        with:
          script: |
            const issueNumber = Number(process.env.ISSUE_NUMBER || 0);
            if (!issueNumber) {
              core.setFailed('Missing agent issue number.');
              return;
            }
            const { owner, repo } = context.repo;
            const baselineLabels = ['audit:agent', 'audit:ux', 'audit:ia', 'audit:correctness'];
            const readyLabel = 'ai:ready';
            const inProgressLabel = 'ai:in-progress';

            const mergeLabels = (existing, { targetAiState }) => {
              const current = (existing || []).map((label) =>
                typeof label === 'string' ? label : label.name,
              );
              const preserved = current.filter((label) => label !== readyLabel && label !== inProgressLabel);
              return Array.from(new Set([...preserved, ...baselineLabels, targetAiState]));
            };

            try {
              await github.rest.issues.addAssignees({
                owner,
                repo,
                issue_number: issueNumber,
                assignees: ['copilot'],
              });

              const issue = await github.rest.issues.get({
                owner,
                repo,
                issue_number: issueNumber,
              });

              await github.rest.issues.update({
                owner,
                repo,
                issue_number: issueNumber,
                labels: mergeLabels(issue.data.labels, { targetAiState: inProgressLabel }),
              });
            } catch (error) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: 'Automatic @copilot assignment failed. Maintainer can run: `gh issue edit ' + issueNumber + ' --add-assignee @copilot`.',
              });
            }

      - name: PR agent summary
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          pr_number="${{ steps.guard.outputs.pr_number }}"
          pr_url="${{ steps.guard.outputs.pr_url }}"
          should_run="${{ steps.guard.outputs.should_run }}"
          evidence_url="${{ steps.guard.outputs.evidence_run_url }}"
          resolution_mode="${{ steps.guard.outputs.resolution_mode }}"
          issue_number="${{ steps.issue.outputs.issue_number }}"

          {
            echo "## PR Agent Summary"
            echo ""
            echo "- Trigger event: \`${{ github.event_name }}\`"
            echo "- Resolution mode: \`${resolution_mode:-unknown}\`"
            if [[ -n "${pr_number}" ]]; then
              echo "- PR: #${pr_number} (${pr_url})"
            fi
            if [[ -n "${evidence_url}" ]]; then
              echo "- PR evidence run: ${evidence_url}"
            fi
            if [[ -z "${should_run}" ]]; then
              echo "- Outcome: failed during PR context resolution"
            elif [[ "${should_run}" == "true" ]]; then
              echo "- Outcome: processed"
              echo "- Agent issue number: \`${issue_number:-n/a}\`"
            else
              echo "- Outcome: skipped (missing \`audit:agent\` label on PR-triggered path)"
            fi
          } >> "$GITHUB_STEP_SUMMARY"
