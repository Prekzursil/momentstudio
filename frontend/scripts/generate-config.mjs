import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

function parseDotEnv(contents) {
  const result = {};
  for (const line of contents.split(/\r?\n/)) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    const eq = trimmed.indexOf('=');
    if (eq === -1) continue;
    const key = trimmed.slice(0, eq).trim();
    let value = trimmed.slice(eq + 1).trim();
    if (
      (value.startsWith('"') && value.endsWith('"') && value.length >= 2) ||
      (value.startsWith("'") && value.endsWith("'") && value.length >= 2)
    ) {
      value = value.slice(1, -1);
    }
    result[key] = value;
  }
  return result;
}

function firstExisting(paths) {
  for (const candidate of paths) {
    if (fs.existsSync(candidate)) return candidate;
  }
  return null;
}

const scriptsDir = path.dirname(fileURLToPath(import.meta.url));
const frontendRoot = path.resolve(scriptsDir, '..');
let packageVersion = '';
try {
  const pkg = JSON.parse(fs.readFileSync(path.join(frontendRoot, 'package.json'), 'utf8'));
  if (typeof pkg?.version === 'string') packageVersion = pkg.version;
} catch {
  packageVersion = '';
}
const envPath = firstExisting([
  path.join(frontendRoot, '.env'),
  path.join(frontendRoot, '.env.local'),
  path.join(frontendRoot, '.env.example')
]);

const parsed = envPath ? parseDotEnv(fs.readFileSync(envPath, 'utf8')) : {};

const apiBaseUrl = process.env.API_BASE_URL ?? parsed.API_BASE_URL ?? '/api/v1';
const appEnv = process.env.APP_ENV ?? parsed.APP_ENV ?? 'development';
const appVersion = process.env.APP_VERSION ?? parsed.APP_VERSION ?? packageVersion;
const stripeEnvRaw = process.env.STRIPE_ENV ?? parsed.STRIPE_ENV ?? 'test';
const stripeEnv = String(stripeEnvRaw).trim().toLowerCase();
const stripeMode = stripeEnv === 'live' || stripeEnv === 'production' || stripeEnv === 'prod' ? 'live' : 'test';
const stripePublishableKeyLegacy = process.env.STRIPE_PUBLISHABLE_KEY ?? parsed.STRIPE_PUBLISHABLE_KEY ?? '';
const stripePublishableKeyTest = process.env.STRIPE_PUBLISHABLE_KEY_TEST ?? parsed.STRIPE_PUBLISHABLE_KEY_TEST ?? '';
const stripePublishableKeyLive = process.env.STRIPE_PUBLISHABLE_KEY_LIVE ?? parsed.STRIPE_PUBLISHABLE_KEY_LIVE ?? '';
const stripePublishableKey =
  stripePublishableKeyLegacy || (stripeMode === 'live' ? stripePublishableKeyLive : stripePublishableKeyTest) || '';
const paypalEnabledRaw = process.env.PAYPAL_ENABLED ?? parsed.PAYPAL_ENABLED ?? '';
const netopiaEnabledRaw = process.env.NETOPIA_ENABLED ?? parsed.NETOPIA_ENABLED ?? '';
const addressAutocompleteEnabledRaw = process.env.ADDRESS_AUTOCOMPLETE_ENABLED ?? parsed.ADDRESS_AUTOCOMPLETE_ENABLED ?? '';
const sentryDsn = process.env.SENTRY_DSN ?? parsed.SENTRY_DSN ?? '';
const captchaSiteKey = process.env.CAPTCHA_SITE_KEY ?? parsed.CAPTCHA_SITE_KEY ?? '';
const paypalEnabled = ['1', 'true', 'yes', 'on'].includes(String(paypalEnabledRaw).trim().toLowerCase());
const netopiaEnabled = ['1', 'true', 'yes', 'on'].includes(String(netopiaEnabledRaw).trim().toLowerCase());
const addressAutocompleteEnabled = ['1', 'true', 'yes', 'on'].includes(String(addressAutocompleteEnabledRaw).trim().toLowerCase());

const outPath = path.join(frontendRoot, 'src', 'assets', 'app-config.js');
fs.mkdirSync(path.dirname(outPath), { recursive: true });

const config = {
  apiBaseUrl,
  appEnv,
  appVersion,
  stripePublishableKey,
  paypalEnabled,
  netopiaEnabled,
  addressAutocompleteEnabled,
  sentryDsn,
  captchaSiteKey
};
const payload = `// Auto-generated by scripts/generate-config.mjs\nwindow.__APP_CONFIG__ = ${JSON.stringify(config, null, 2)};\n`;

fs.writeFileSync(outPath, payload, 'utf8');
console.log(`Wrote ${path.relative(frontendRoot, outPath)} from ${envPath ? path.relative(frontendRoot, envPath) : 'defaults'}`);
