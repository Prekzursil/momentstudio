name: Agent Task Queue

on:
  issues:
    types: [labeled]

permissions:
  contents: read
  issues: write

jobs:
  queue:
    if: ${{ github.event.label.name == 'agent:ready' && github.event.issue.pull_request == null }}
    runs-on: ubuntu-latest
    env:
      VERIFY_COMMAND: make verify
    steps:
      - name: Build agent task packet and notify Copilot
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = issue.number;

            const currentLabels = (issue.labels || []).map(l => typeof l === "string" ? l : l.name);
            const hadReady = currentLabels.includes("agent:ready");
            const hadInProgress = currentLabels.includes("agent:in-progress");

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number,
              per_page: 100,
            });

            const existingContract = comments.find(c =>
              c.body?.includes("### Execution Contract") &&
              c.body?.includes(`- #${issue_number}: ${issue.title}`)
            );

            if (existingContract) {
              core.info("Execution contract comment already exists; skipping duplicate enqueue.");
              return;
            }

            let addedInProgress = false;
            let removedReady = false;

            try {
              if (!hadInProgress) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number,
                  labels: ["agent:in-progress"],
                });
                addedInProgress = true;
              }

              if (hadReady) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number,
                    name: "agent:ready",
                  });
                  removedReady = true;
                } catch (error) {
                  if (error.status === 404) {
                    core.info("agent:ready was already removed.");
                  } else {
                    throw error;
                  }
                }
              }

              const intro = repo === "SWFOC-Mod-Menu"
                ? "@copilot Please implement this task using SWFOC runtime safety guardrails."
                : "@copilot Please implement this task using repository guardrails.";

              const lines = [
                intro,
                "",
                "### Execution Contract",
                "1. Keep the change minimal and in scope.",
                "2. Run deterministic verification before requesting review.",
                `3. Required verification command: \`${process.env.VERIFY_COMMAND}\`.`,
                "4. Include PR sections: Summary, Risk, Evidence, Rollback, Scope Guard.",
                "5. Do not merge; maintainers perform final human review.",
              ];

              if (repo === "SWFOC-Mod-Menu") {
                lines.push(
                  "6. Keep profile compatibility explicit (`base`, `aotr`, `roe`, `custom`).",
                  "7. Include reason-code-level diagnostics for runtime behavior changes.",
                  "8. Attach repro-bundle evidence for runtime/mod bugfixes.",
                );
              }

              lines.push(
                "",
                "### Source Issue",
                `- #${issue_number}: ${issue.title}`,
              );

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: lines.join("\n"),
              });
            } catch (error) {
              core.warning(`Queue transition failed: ${error.message}`);

              if (addedInProgress && !hadInProgress) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number,
                    name: "agent:in-progress",
                  });
                } catch (rollbackError) {
                  core.warning(`Rollback remove agent:in-progress failed: ${rollbackError.message}`);
                }
              }

              if (removedReady && hadReady) {
                try {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number,
                    labels: ["agent:ready"],
                  });
                } catch (rollbackError) {
                  core.warning(`Rollback add agent:ready failed: ${rollbackError.message}`);
                }
              }

              throw error;
            }
